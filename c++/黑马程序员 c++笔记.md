# c++笔记

### c++ 排序函数sort

 **基础使用**

    sort(a+m,a+n,cmp)  //cmp是函数或仿函数

**cmp**原理为真时，第一个数字放前面

使用头文件`#include<algorithm>`

### 指针常量和常量指针
1、指针常量——指针类型的常量(int *const p)
本质上一个常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。在指针常量中，指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化。用法如下：

    int a = 10, b = 20;
    int * const p = &a;
    *p = 30; // p指向的地址是一定的,但其内容可以修改

2、常量指针——指向“常量”的指针(const int *p, int const *p)
常量指针本质上是一个指针，常量表示指针指向的内容，说明该指针指向一个“常量”。在常量指针中，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。用法如下：

    int a = 10, b = 20;
    const int *p = &a;
    p = &b; // 指针可以指向其他地址，但是内容不可以改变

>指针常量：指针的值是常量，始终指向同一个地址
>常量指针：指向常量的指针

### 引用数据类型()

**作用**：给变量起别名

**语法**：类型名称& 变量名 = 对应类型变量名称
    int& b = a;    //给变量 a 所在内存赋予另外一个别名 b

**注意**:
1.引用必须初始化
2.初始化后不能更改

#### 引用做函数参数

**作用**：函数传参时，利用引用让形参修饰实参
**优点**：简化指针修改实参

#### 引用做函数返回值

**注意**:
1.不要返回局部变量的引用
2.函数的调用可作为左值

#### 引用的本质
**本质**:引用的本质在c++內部实现是一个指针常量

        int a = 10;
        //自动转换为 int* const ref = &a;
        int& ref = a;
        ref = 20;内部发现ref是引用,自动帮转为:*ref = 20;

#### 常量引用

**使用场景**：用来修饰形参，防止误操作

    //int& ref = 10;引用本身需要合法的内存空间，因此这一行错误
    //加入const就可以了,编译器优化代码,int temp = 10;const int& ref = temp;
    const int& = 10;

### 内存分区模型

+ 代码段：放函数体二进制代码，由操作系统管理（共享、只读）
+ 数据段：存放全局变量和静态变量以及常量(不包括局部常量)，程序结束后系统释放
+ 栈区：由编译器自动分配释放，放函数的参数值及局部变量
+ 堆区:由程序员分配和释放，若程序员不释放则在程序结束时由操作系统回收
  > 代码区和全局区是代码运行前划分，运行后出现栈区和堆区
  >不要返回局部变量的地址
  >用new开辟堆内存

#### new操作符

**语法：**

new 数据类型
new 数据类型（初始值）
new 数据类型[常量表达式]

     int  * p1=new int;
 
     int  *p2=new int(2); // *p2初始化值是2,这样直接在定义后面初始化是可以的
    //也可以单独赋值  *p2=2;
    
     //如果不想使用指针,可以定义一个变量,在new之前用  “*”表示new出来的内容
      int q = *new int;
      q = 1;
      cout << q << endl;
    
      int  *p3=new int[1000] //申请1000个单位内存空间

#### 函数默认参数

**语法**：返回值类型 函数名 （参数=默认值）{}

    int func (int a,int b = 20,int c = 20){}

**注意事项**:
1.如果某个位置已经有默认参数，从这个位置往后，从左到右都必须有默认值
2.如果函数声明有默认参数，函数实现不能有默认参数

    int fun(int a = 10,int b = 10);

    int fun(int a = 10,int b = 10){
        return a+b;
    } //以上代码是错误的

#### 函数占位参数
**语法**：返回值类型 函数名 （数据类型）{}

    void func (int a,int=10){
        cout<<"this is func"<<endl;
    }

    int main(){
        func(10);
        return 0;
    }//占位参数可有默认参数

#### 函数重载
**作用**：函数名可以重复，提高复用性
**条件**:
+ 同一个作用域下
+ 函数名称相同
+ 参数列表不同

**注意**：函数的返回值不可作为函数重载的条件

##### 函数重载注意事项
1.引用作为重载的条件

    void fun (int &a){

    }

    void fun(const int &a){

    }

2.函数重载碰到默认参数
     void fun (int a,int b = 10){

    }

    void fun(int a,int b){

    }

#### 类和对象