# 算法

## 差分

b[i]=a[i]-a[i-1]

## 容器（vector）

> 可变长度数组

**vector的使用**：

    vector<int> a;      //定义了一个int类型的vector容器a
    vector<int> b[100]; //定义了一个int类型的vector容器b组
    struct rec
    {
      ···
    };
    vector<rec> c;            //定义了一个rec类型的vector容器c
    vector<int>::iterator it; //vector的迭代器，与指针类似

**具体操作**：

    a.size()       //返回实际长度（元素个数），O(1)复杂度
    a.empty()      //容器为空返回1，否则返回0，O(1)复杂度
    a.clear()      //把vector清空
    a.begin()      //返回指向第一个元素的迭代器，*a.begin()与a[0]作用相同
    a.end()        //越界访问，指向vector尾部，指向第n个元素再往后的边界
    a.front()      //返回第一个元素的值，等价于*a.begin和a[0]
    a.back()       //返回最后一个元素的值，等价于*--a.end()和a[size()-1]
    a.push_back(x) //把元素x插入vector尾部
    a.pop_back()   //删除vector中最后一个元素

**遍历**：
    
    for( int i=0;i<a.size();i++) cout<<a[i]<<endl;  //当成数组

## 队列（queue）

**queue的使用**：

    queue<string> myqueue;

**具体操作**：

    front()：返回 queue 中第一个元素的引用。
    back()：返回 queue 中最后一个元素的引用。
    push(const T& obj)：在 queue 的尾部添加一个元素的副本。
    pop()：删除 queue 中的第一个元素。
    size()：返回 queue 中元素的个数。
    empty()：如果 queue 中没有元素的话，返回 true。

## map

**map的使用**：

    map<char, int> mymap1;
    map<string, int> mymap2;

**具体操作**：

    int map.size();//查询map中有多少对元素
    bool empty();// 查询map是否为空
    map[key]=value
    map<int, string> map;

    //如果map中没有关键字2233，使用[]取值会导致插入
    //因此，下面语句不会报错，但会使得输出结果结果为空
    cout<<map[2233]<<endl;

    //但是使用使用at会进行关键字检查，因此下面语句会报错
    map.at(2016) = "Bob";
    m.count(key)：//由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。
    m.find(key)：//返回迭代器，判断是否存在。